import * as fs from 'fs/promises';
import * as path from 'path';
import { RVSession, StorageAdapter } from '../types';
import { logger } from '../utils/logger';

export class JsonStorageService implements StorageAdapter {
  private dataDir: string;

  constructor(dataDir: string) {
    this.dataDir = dataDir;
  }

  private getSessionDir(id: string): string {
    return path.join(this.dataDir, 'sessions', id);
  }

  private getSessionPath(id: string): string {
    return path.join(this.getSessionDir(id), 'session.json');
  }

  private getSessionMarkdownPath(id: string): string {
    return path.join(this.getSessionDir(id), 'session.md');
  }

  private generateMarkdown(session: RVSession): string {
    const lines: string[] = [];

    lines.push(`# RV Session: ${session.name || session.id}`);
    lines.push('');
    lines.push(`**Session ID:** ${session.id}`);
    lines.push(`**Created:** ${session.createdAt.toLocaleString()}`);
    lines.push(`**Reveal At:** ${session.revealAt.toLocaleString()}`);
    lines.push(`**Number of Targets:** ${session.targets.length}`);
    lines.push('');

    if (session.notes) {
      lines.push('## Notes');
      lines.push('');
      lines.push(session.notes);
      lines.push('');
    }

    lines.push('## Targets');
    lines.push('');

    session.targets.forEach((target, index) => {
      lines.push(`### Target ${index + 1}: ${target.code}`);
      lines.push('');
      lines.push(`**Code:** \`${target.code}\``);
      lines.push(`**Status:** ${target.revealed ? '✅ Revealed' : '⏳ Pending'}`);
      lines.push(`**Source:** ${target.targetSource}`);

      if (target.revealed) {
        lines.push('');
        lines.push('**Description:**');
        lines.push('');
        lines.push(target.targetDescription);
        lines.push('');
        lines.push('**Image URL:**');
        lines.push('');
        lines.push(target.targetUrl);
        lines.push('');
        if (target.revealedAt) {
          lines.push(`**Revealed At:** ${target.revealedAt.toLocaleString()}`);
        }
      }

      lines.push('');
      lines.push('---');
      lines.push('');
    });

    lines.push('');
    lines.push('---');
    lines.push('');
    lines.push('*Generated by Glimpse RV Testing CLI*');

    return lines.join('\n');
  }

  async ensureDataDirectory(): Promise<void> {
    const sessionsDir = path.join(this.dataDir, 'sessions');
    try {
      await fs.mkdir(sessionsDir, { recursive: true });
    } catch (error) {
      logger.error('Failed to create data directory:', error);
      throw error;
    }
  }

  async saveSession(session: RVSession): Promise<void> {
    await this.ensureDataDirectory();
    const sessionDir = this.getSessionDir(session.id);
    const jsonPath = this.getSessionPath(session.id);
    const mdPath = this.getSessionMarkdownPath(session.id);

    try {
      // Create session directory
      await fs.mkdir(sessionDir, { recursive: true });

      // Save JSON file
      await fs.writeFile(jsonPath, JSON.stringify(session, null, 2), 'utf-8');
      logger.debug(`Session ${session.id} saved to ${jsonPath}`);

      // Save Markdown file
      const markdown = this.generateMarkdown(session);
      await fs.writeFile(mdPath, markdown, 'utf-8');
      logger.debug(`Session markdown saved to ${mdPath}`);
    } catch (error) {
      logger.error('Failed to save session:', error);
      throw new Error(`Failed to save session: ${error}`);
    }
  }

  async getSession(id: string): Promise<RVSession | null> {
    const filePath = this.getSessionPath(id);

    try {
      const data = await fs.readFile(filePath, 'utf-8');
      const session = JSON.parse(data);
      // Convert date strings back to Date objects
      session.createdAt = new Date(session.createdAt);
      session.revealAt = new Date(session.revealAt);
      if (session.revealedAt) {
        session.revealedAt = new Date(session.revealedAt);
      }
      return session;
    } catch (error) {
      if ((error as NodeJS.ErrnoException).code === 'ENOENT') {
        return null;
      }
      logger.error('Failed to read session:', error);
      throw error;
    }
  }

  async getAllSessions(): Promise<RVSession[]> {
    await this.ensureDataDirectory();
    const sessionsDir = path.join(this.dataDir, 'sessions');

    try {
      const entries = await fs.readdir(sessionsDir, { withFileTypes: true });
      const sessions: RVSession[] = [];

      for (const entry of entries) {
        // Skip files, only process directories
        if (entry.isDirectory()) {
          const id = entry.name;
          const session = await this.getSession(id);
          if (session) {
            sessions.push(session);
          }
        }
      }

      // Sort by creation date (newest first)
      return sessions.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime());
    } catch (error) {
      logger.error('Failed to list sessions:', error);
      return [];
    }
  }

  async updateSession(id: string, updates: Partial<RVSession>): Promise<void> {
    const session = await this.getSession(id);
    if (!session) {
      throw new Error(`Session ${id} not found`);
    }

    const updatedSession = { ...session, ...updates };
    await this.saveSession(updatedSession);
  }

  async deleteSession(id: string): Promise<void> {
    const sessionDir = this.getSessionDir(id);

    try {
      await fs.rm(sessionDir, { recursive: true, force: true });
      logger.debug(`Session ${id} deleted`);
    } catch (error) {
      logger.error('Failed to delete session:', error);
      throw new Error(`Failed to delete session: ${error}`);
    }
  }
}
